Changed from version 1.1 --> 1.11

bug fixes: 
- bug fix in border-border communication. 


Index: src/serial/myalloc.cc
===================================================================
--- src/serial/myalloc.cc	(revision 1006)
+++ src/serial/myalloc.cc	(revision 1011)
@@ -39,8 +39,10 @@
 
 // class to store items of same size in a stack 
 // also number of used items outside is stored 
-struct AllocEntry {
+class AllocEntry {
 
+public:
+
   // N verfolgt die Anzahl der angelegten Objekte der entsprechenden
   // Gr"osse, die in Gebrauch sind, auf dem Stack liegen die Objekte,
   // f"ur die delete aufgerufen wurde, die aber nicht an free () zur"uck-
@@ -48,10 +50,14 @@
 
   long N ;
 
-  stack <void * > S ;
+  stack < void * > S ;
 
   AllocEntry () : N (0), S () {}
 
+  AllocEntry(const AllocEntry& other) 
+    : N(other.N) , S(other.S) 
+  {} 
+  
   ~AllocEntry () 
   {
     while (!S.empty ()) 
@@ -61,7 +67,7 @@
     }
     return ;
   }
-} ;
+};
 
 // map holding AllocEntries for sizes 
 static map < size_t, AllocEntry, less < size_t > > * freeStore = 0 ;
@@ -126,7 +132,7 @@
 {
   assert(s > 0);
   {
-    AllocEntry & fs ((*freeStore) [s]) ;
+    AllocEntry & fs = ((*freeStore) [s]) ;
     ++ fs.N ;
     if (fs.S.empty ()) {
       void * p = malloc (s) ;
Index: src/serial/myalloc.h
===================================================================
--- src/serial/myalloc.h	(revision 1006)
+++ src/serial/myalloc.h	(revision 1011)
@@ -74,8 +74,16 @@
 #else // DONT_USE_ALUGRID_ALLOC 
 
 // dummy class 
-class MyAlloc {};
+class MyAlloc 
+{
+public:  
+  // if called, freeing objects is allowed again 
+  inline static void unlockFree(void *) {}
 
+  // if called free of objects is not allowed 
+  inline static void lockFree (void *) {} 
+};
+
 #endif // DONT_USE_ALUGRID_ALLOC
 
 #endif // MYALLOC_H_INCLUDED
Index: src/serial/serialize.h
===================================================================
--- src/serial/serialize.h	(revision 1006)
+++ src/serial/serialize.h	(revision 1011)
@@ -61,6 +61,11 @@
   inline void clear() { _wb = 0; _rb = 0; }
   // reset read position 
   inline void resetReadPosition() { _rb = 0; }
+  
+  // return's true if size > 0 and read position is zero
+  // i.e. a read othe stream will result some valid data  
+  inline bool validToRead () const { return (_wb > 0) && (_rb == 0); }
+
   // return size of bytes allready written to stream 
   inline int size() const { return _wb; }
 
Index: src/duneinterface/gitter_dune_pll_impl.cc
===================================================================
--- src/duneinterface/gitter_dune_pll_impl.cc	(revision 1006)
+++ src/duneinterface/gitter_dune_pll_impl.cc	(revision 1011)
@@ -339,6 +339,7 @@
     item.reserveBuffer( nl + 1 );
     DataBufferType & data = item.commBuffer();
 
+    // only gather master data once 
     if ( dataHandle.containsItem( item ) ) 
     {
       // pack master data 
@@ -383,6 +384,18 @@
  
   IteratorSTI < HItemType > & iter = *(a.first);
 
+  // create new link vector 
+  vector< int > newLink( nl );
+  for(int link=0; link<nl ; ++link) 
+  {
+    newLink[ link ] = link;
+  }
+
+  // if myLink == link then write master data
+  // instead of data of link 
+  // we do not send link i its own data
+  newLink[myLink] = nl;
+
   // for all master items 
   for (iter.first (); ! iter.done () ; iter.next ()) 
   {
@@ -395,9 +408,11 @@
       for(int link = 0; link<nl; ++link)
       {
         BufferType & localBuff = dataBuff[link];
-        if( localBuff.size() > 0 ) 
+
+        // check if stream has been read, if not scatter data 
+        // this will unpack data on master only once 
+        if( localBuff.validToRead() ) 
         {
-          localBuff.resetReadPosition();
           dataHandle.recvData(localBuff, item);
         }
       }
@@ -410,12 +425,9 @@
 
       for(int link = 0; link<nl; ++link)
       {
-        // if myLink == link then write master data
-        // instead of data of link 
-        // we do not send link i its own data
-        int l = (link == myLink) ? nl : link;
-
-        BufferType & localBuff = dataBuff[l];
+        // use new link to send master data to link we are sending for 
+        BufferType & localBuff = dataBuff[ newLink[link] ];
+        // get size 
         int s = localBuff.size();
         sendBuff.writeObject(s);
         // if buffer size > 0 write hole buffer to stream 
Index: configure.ac
===================================================================
--- configure.ac	(revision 1006)
+++ configure.ac	(revision 1011)
@@ -2,8 +2,8 @@
 AC_PREREQ(2.50)
 
 # current version of ALUGrid
-AC_INIT(ALUGrid, 1.1, alugrid@mathematik.uni-freiburg.de)
-AM_INIT_AUTOMAKE(ALUGrid, 1.1, alugrid@mathematik.uni-freiburg.de)
+AC_INIT(ALUGrid, 1.11, alugrid@mathematik.uni-freiburg.de)
+AM_INIT_AUTOMAKE(ALUGrid, 1.11, alugrid@mathematik.uni-freiburg.de)
 
 # default install path is current directory 
 AC_PREFIX_DEFAULT([`pwd`])
